<!DOCTYPE html>
<html>

<head>
    <style>
        #tickerScroller {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 0;
            background-color: #333;
            color: white;
            overflow: hidden;
            z-index: 9999;
        }

        #tickerContainer {
            display: flex;
            align-items: center;
            animation: slide linear infinite;
            white-space: nowrap;
            font-family: 'Arial', sans-serif;
        }

        .tickerText {
            margin-right: 50px;
        }

        @keyframes slide {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        /* Responsive Design */
        @media only screen and (max-width: 600px) {
            .tickerText {
                font-size: 14px;
                margin-right: 30px;
            }
        }
    </style>
    </style>
</head>

<body>
    <div id="tickerScroller">
        <div id="tickerContainer"></div>
    </div>

    <script>
        async function fetchCryptoData() {
            try {
                const cache = localStorage.getItem('cryptoDataCache');
                const cacheDuration = 120000; // Cache duration in milliseconds, e.g., 120000ms for 2 minutes

                if (cache) {
                    const { data, timestamp } = JSON.parse(cache);
                    if (timestamp + cacheDuration > Date.now()) {
                        return data; // Use cached data if still valid
                    }
                }

                // Define the top 25 cryptocurrency IDs in an array
                const top25CoinIds = [
                    "bitcoin",
                    "ethereum",
                    "tether",
                    "cardano",
                    "usd-coin",
                    "solana",
                    "polkadot",
                    "dogecoin",
                    "avalanche-2",
                    "terra-luna",
                    "binance-usd",
                    "wrapped-bitcoin",
                    "litecoin",
                    "chainlink",
                    "algorand",
                    "bitcoin-cash",
                    "matic-network",
                    "internet-computer",
                    "stellar",
                    "filecoin",
                    "tron",
                    "ethereum-classic",
                    "vechain",
                ];
                const url = `https://api.coingecko.com/api/v3/simple/price?ids=${top25CoinIds.join(",")}&vs_currencies=usd&include_24hr_change=true`;
                const response = await fetch(url);
                const data = await response.json();

                // Cache the fetched data with a timestamp
                localStorage.setItem('cryptoDataCache', JSON.stringify({
                    data: top25CoinIds.map(id => ({
                        name: id.toUpperCase(),
                        value: data[id].usd,
                        change: data[id].usd_24h_change,
                    })), timestamp: Date.now()
                }));

                return top25CoinIds.map(id => ({
                    name: id.toUpperCase(),
                    value: data[id].usd,
                    change: data[id].usd_24h_change,
                }));
            } catch (error) {
                console.error("Failed to fetch data:", error);
                return [];
            }
        }

        function createTickerItem(item) {
            const span = document.createElement("span");
            span.className = "tickerText";
            const trendSymbol = item.change >= 0 ? "↑" : "↓";
            const trendColor = item.change >= 0 ? "green" : "red";
            span.innerHTML = `<span style='color: ${trendColor};'>${trendSymbol}</span>
            <span style='color: ${trendColor};'> ${item.name}: </span> <span style='color: ${trendColor};'> ${item.value} $ </span>`;
            return span;
        }

        async function updateTicker() {
            const cryptoData = await fetchCryptoData();
            const tickerContainer = document.getElementById("tickerContainer");
            tickerContainer.innerHTML = "";
            cryptoData.forEach(item => tickerContainer.appendChild(createTickerItem(item)));
        }

        function calculatePercentagePosition() {
            const tickerContainer = document.getElementById('tickerContainer');
            const containerWidth = tickerContainer.offsetWidth;
            const parentWidth = tickerContainer.parentElement.offsetWidth;
            const totalWidth = containerWidth + parentWidth; // Total path of the animation

            const computedStyle = window.getComputedStyle(tickerContainer);
            const matrix = new WebKitCSSMatrix(computedStyle.transform);
            const currentPosition = matrix.m41; // Current X translation

            // Convert position to percentage of total path
            const positionPercent = (currentPosition + containerWidth) / totalWidth * 100;
            return positionPercent;
        }

        function applySavedPosition(positionPercent) {
            const tickerContainer = document.getElementById('tickerContainer');
            // Remove the current animation to reset it
            tickerContainer.style.animation = 'none';

            // Update the @keyframes rule to start from the saved position
            const keyframes = `@keyframes slide {
                from { transform: translateX(${100 - positionPercent}%); }
                to { transform: translateX(-100%); }
            }`;

            // Apply the new @keyframes rule
            let styleSheet = document.createElement('style');
            styleSheet.type = 'text/css';
            styleSheet.innerHTML = keyframes;
            document.head.appendChild(styleSheet);

            // Restart the animation
            requestAnimationFrame(() => {
                tickerContainer.style.animation = `slide 120s linear infinite`;
            });
        }


        document.addEventListener("DOMContentLoaded", async () => {
            await updateTicker();
            setInterval(updateTicker, 120000); // Update every 2 minutes

            // Retrieve saved position or start from 0%
            const savedPosition = localStorage.getItem('tickerPosition') || 0;
            applySavedPosition(savedPosition);

            // Periodically save the current position
            setInterval(() => {
                const positionPercent = calculatePercentagePosition();
                localStorage.setItem('tickerPosition', positionPercent);
            }, 1000); // Save position every 1 second
        });
    </script>
</body>

</html>